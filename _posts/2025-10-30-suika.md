---
layout: post
title:  "fruit game"
date:   2025-10-30 09:29:20 +0700
categories: jekyll update
usemathjax: true
---
<style>
  body {
    margin: 0;
    background: black;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: white;
    font-family: Arial, sans-serif;
  }
  canvas {
    background: white;
    border: 4px solid #333;
    border-radius: 10px;
    margin-top: 20px;
  }
  #score {
    font-size: 20px;
    margin-top: 10px;
  }
  #lost {
    font-size: 28px;
    color: red;
    margin-top: 10px;
    display: none;
  }
  #nextFruit {
    font-size: 18px;
    margin-top: 10px;
    display: flex;
    align-items: center;
  }
</style>
</head>
<body>
<h1>Fruit Game</h1>
<div id="score">Score: 0</div>
<div id="lost">You Lost! Restarting...</div>
<div id="nextFruit">Next: <canvas id="nextFruitCanvas" width="50" height="50"></canvas></div>
<canvas id="gameCanvas" width="400" height="600"></canvas>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('nextFruitCanvas');
  const nextCtx = nextCanvas.getContext('2d');

  const GRAVITY = 0.1;
  const SPAWN_DELAY = 500; // ms
  const LOSS_LINE = 120; // y position

  const FRUITS = [
    { r: 24, color: 'brown'},
    { r: 31.5, color: 'red' },
    { r: 40.5, color: 'orange' },
    { r: 51, color: 'yellow' },
    { r: 63, color: 'green' },
    { r: 76.5, color: 'purple'},
    { r: 91.5, color: 'cyan'},
    { r: 108, color: 'blue'},
    { r: 127.5, color: 'pink'}
  ];

  let lastSpawnTime = 0;
  let nextFruitIndex = Math.floor(Math.random() * 4);
  let currentFruit = createFruit();
  let fruits = [];
  let score = 0;
  let lost = false;

  function resetGame() {
    fruits = [];
    score = 0;
    lost = false;
    document.getElementById('score').textContent = 'Score: 0';
    document.getElementById('lost').style.display = 'none';
    nextFruitIndex = Math.floor(Math.random() * 4);
    currentFruit = createFruit();
    drawNextFruit();
  }

  function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
  }

  function createFruit() {
    const f = FRUITS[nextFruitIndex];
    nextFruitIndex = Math.floor(Math.random() * 4); // pick next
    drawNextFruit();
    return {
      x: canvas.width / 2,
      y: LOSS_LINE + f.r + 10,
      r: f.r,
      color: f.color,
      vx: 0,
      vy: 0,
      merged: false
    };
  }

  function drawNextFruit() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    const f = FRUITS[nextFruitIndex];
    nextCtx.beginPath();
    nextCtx.arc(nextCanvas.width/2, nextCanvas.height/2, f.r, 0, Math.PI*2);
    nextCtx.fillStyle = f.color;
    nextCtx.fill();
  }

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    currentFruit.x = e.clientX - rect.left;
  });

  canvas.addEventListener('click', () => {
    if (lost) return;
    const now = Date.now();
    if (now - lastSpawnTime < SPAWN_DELAY) return;
    lastSpawnTime = now;

    const copy = typeof structuredClone === 'function' ? structuredClone(currentFruit) : { ...currentFruit };
    fruits.push(copy);
    currentFruit = createFruit();
  });

  function update() {
    if (lost) return;

    fruits.forEach((f) => {
      f.vy += GRAVITY;
      f.y += f.vy;
      f.x += f.vx;

      if (f.y + f.r > canvas.height) {
        f.y = canvas.height - f.r;
        f.vy *= -0.4;
        f.vx *= 0.98;
      }

      if (f.x - f.r < 0) {
        f.x = f.r;
        f.vx *= -0.4;
      }

      if (f.x + f.r > canvas.width) {
        f.x = canvas.width - f.r;
        f.vx *= -0.4;
      }
    });

    resolveCollisions();
    checkMerge();
    checkLoss();
  }

  function resolveCollisions() {
    for (let i = 0; i < fruits.length; i++) {
      for (let j = i + 1; j < fruits.length; j++) {
        const a = fruits[i];
        const b = fruits[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy) || 0.0001;
        const minDist = a.r + b.r;

        if (dist < minDist) {
          const overlap = minDist - dist;
          const nx = dx / dist;
          const ny = dy / dist;

          a.x -= nx * overlap / 2;
          a.y -= ny * overlap / 2;
          b.x += nx * overlap / 2;
          b.y += ny * overlap / 2;

          const relVelX = b.vx - a.vx;
          const relVelY = b.vy - a.vy;
          const dot = relVelX * nx + relVelY * ny;

          if (dot < 0) {
            const bounce = -dot * 0.8;
            a.vx -= nx * bounce;
            a.vy -= ny * bounce;
            b.vx += nx * bounce;
            b.vy += ny * bounce;
          }
        }
      }
    }
  }

  function checkMerge() {
    for (let i = 0; i < fruits.length; i++) {
      for (let j = i + 1; j < fruits.length; j++) {
        const a = fruits[i];
        const b = fruits[j];
        const dist = Math.hypot(a.x - b.x, a.y - b.y);
        const mergeDist = (a.r + b.r) * 1.1;

        if (dist < mergeDist && a.color === b.color && !a.merged && !b.merged) {
          a.merged = b.merged = true;
          const nextIndex = FRUITS.findIndex(fr => fr.r === a.r) + 1;

          if (nextIndex < FRUITS.length) {
            const bigger = FRUITS[nextIndex];
            fruits.push({
              x: (a.x + b.x) / 2,
              y: (a.y + b.y) / 2,
              r: bigger.r,
              color: bigger.color,
              vx: 0,
              vy: 0,
              merged: false
            });
            // award points proportional to new fruit size
            score += Math.floor(bigger.r / 2);
          } else {
            score += 50; // bonus for max fruit
          }

          document.getElementById('score').textContent = 'Score: ' + score;
          fruits = fruits.filter(f => !f.merged);
          i = -1;
          break;
        }
      }
    }
  }

  function checkLoss() {
    for (const f of fruits) {
      if (f.y - f.r < LOSS_LINE) {
        lost = true;
        document.getElementById('lost').style.display = 'block';
        setTimeout(resetGame, 1500);
        return;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = 'red';
    ctx.beginPath();
    ctx.moveTo(0, LOSS_LINE);
    ctx.lineTo(canvas.width, LOSS_LINE);
    ctx.stroke();

    fruits.forEach(f => {
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
      ctx.fillStyle = f.color;
      ctx.fill();
    });

    ctx.beginPath();
    ctx.arc(currentFruit.x, currentFruit.y, currentFruit.r, 0, Math.PI * 2);
    ctx.fillStyle = currentFruit.color;
    ctx.globalAlpha = 0.6;
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  currentFruit.x = canvas.width / 2;
  currentFruit.y = LOSS_LINE + currentFruit.r + 10;
  drawNextFruit();

  loop();
</script>